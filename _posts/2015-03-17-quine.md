---
layout: post
title: Teaching with Quines
---
I've decided to try to (laboriously) work through *Hacker's Delight* by Henry S. Warren, Jr. The book's preface cites a [quine](http://en.wikipedia.org/wiki/Quine_(computing)) by Vlad Taeerov and Rashit Fakhreyev. Here it is:

{% highlight c linenos %}
main(a){printf(a,34,a="main(a){printf(a,34,%c%s%c,34);}", 34);}
{% endhighlight %}

Though the general recursive structure is obvious, this 64-character program introduces a host of C weirdness. I gave an aborted five-minute version of this for an interview to TF ("teaching fellow") CS50 at Yale next semester. Here are the things I wish I'd gotten to finish exploring on that occasion. As befits my own (in)experience, this will assume very little prior knowledge of C.

1. **One liners.**
A quine's output must replicate its source code exactly. If we broke up the program with newlines, we'd need to cleverly insert \n escape sequences in order to preserve this property. But since whitespace does NOT have any syntactic meaning in C, this (and indeed all) C programs can be written as one liners. N.B. that when dealing with quines, good programming style goes out the window.

2. **Entry points.**
A valid C program must have exactly one main() function. After preprocessing, compiling, and linking, this function is what gets called first by the executable file. Usually you will see `int main(int argc, char *argv[])`. But even though supplying a type signature and passing in the command line arguments is good programming, you don't need to do either.

What surprised me is that text other than `void` did not throw a compiler error. Turns out, you can put any kind of garbage inside the parentheses and it will default to a `(char *)`. Try it:

{% highlight c linenos %}
#include <stdio.h>
main(garbage)
{
	printf(garbage, garbage="Hello, world!\n");
}
{% endhighlight %}

We can smush a string into `garbage` and C is fine with it.
